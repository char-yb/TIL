# 동시성의 미래 - 코루틴과 버츄얼 스레드

1. 전통적 웹 방식

커널 스레드
1개 요청당 1개의 스레드를 사용하는 Thread Per Request 모델

플랫폼 스레드
JVM에서 제공되는 스레드 기본단위로 자원이 한정되므로 무한정 스레드를 늘릴 수 없다.
컨텍스트 스위칭이 빈번하게 일어나기에 성능 저하 우려가 있다.
스레드 풀 튜닝이 요구될 수 있다.

커널 스레드를 사용하기에 무한정 생성이 안되 스레드 풀을 사용
웹 서버의 최대 처리량은 스레드 풀에 생성된 스레드의 수로 제한


2. 리액티브 프로그래밍

비동기-논블로킹의 문제가 되는 콜백 헬을 함수형 프로그래밍 관점으로 해결
리액티브 스트림즈의 구현체는 Project Reactor, RxJava 등등이 존재한다.
Mono, Flux와 같은 리액티브 단위의 Spring Webflux를 적용을 한다.


적용하기엔 러닝커브가 빡세다....

일단 다양한 시나리오에 적용하는 연산자를 알아야하고, 마블 다이어그램에 대한 이해도는 필수이다.
<!-- Webflux에서 블로킹 API가 호출된다면..?  -->

정리하면
리액티브 프로그래밍은 비동기-논블로킹 방식의 여러 문제를 해결한다.
대용량 데이터에 대한 스트리밍 처리 등에서는 다양한 연산자를 제공한다.



3. 코틀린 코루틴

코루틴은 일단 확장 라이브러리이다.
코루틴을 사용하기에 suspend 라는 키워드가 있다.
코루틴은 매우 가볍다.
플랫폼 스레드에서는 오버헤드에 대한 부하가 적다.

코루틴은 스레드에 비해 가볍다.
delay 함수는 지정된 시간만큼 코루틴을 대기시키고
Thread.sleep과 차이점은 스레드가 블로킹되지 않는다.
다수의 동시성을 효율적으로 잡고있다.
launch 내에 Thread.sleep을 사용하게 되면 블로킹되는 환경이 되기에 성능이 저하될 수 밖에 없다.

코루틴 빌터 - 코루틴을 생성하는 함수
runBlocking에 감싸진 코드는 모든 수행이 끝날때까지 스레드가 블로킹된다.
테스트 코드, 스프링배치 등에


launch는 스레드 차단없이 새로운 코루틴을 시작하며 결과를 만들어내지않는 비동기 작업에 적합
async 빌더는 비동기 작업을 통해 결과를 만들어내는 경우 적합하다.
비동기 작업의 결과로 `Deferred`를 반환하는데 await 함수를 통해 async로 수행한 비동기 작업의 결과를 받아올 수 있다.
! 모든 과정에서 스레드는 블로킹되지 않는다.

coroutineScope는 스레드 블로킹 없이 각 동시 작업의 수행이 완료된 후 함수가 종료된다.
coroutineScope 내부의 자식 코루틴에서 에러가 발생되면 몯든 코루틴이 종료된다.
예외 처리가 깔끔해야 할 듯!

어떻게?
빌더 내부에서 try-catch로 내부를 복구하는 방법이 존재.
supervisorScope를 사용해 예외를 부모 코루틴으로 전파하지 않는 방법을 사용
NonCancellable은 다른 코루틴에서 예외가 발생해도 작업이 수행이 되도록 할 수 있다.


코루틴 컨텍스트

Dispatchers - 코루틴이 동작하는 스레드를 결정하는 방법
Dispatchers 내부에는 4가지 방법이 존재한다.

ThreadLocal의 데이터를 코루틴에 전파하는 방법으로
MDC 키워드 알아보자.

MDC를 사용해서 해결하는데 스레드 로컬에 저장하여

withContext(MDCCOntext())를 사용해 유실되지 않도록 방지한다.

정리하면
구조적 동시성으로 계층 구조를 명확히 정의하고 생명 주기 관리가 쉽다.
경량 스레드로 적은 리소스로 대규모 스레드


4. 버추얼 스레드

ProjectRoom
JDK 21에서 정식으로 발탁된 기술
Java 플랫폼 위에서 경량으로 동작하며 높은 처리량을 달성하며



버추얼 스레드 성능 테스트


정리하면
JVM 레벨의 경량 스레드로 적은 리소스로 대규모 동시성 작업을 효율적으로 지원
버추얼 스레드는 기존 스레드 API를 그대로 활용할 수 있도록 설계
Spring Web MVC + 버추얼 스레드는 Spring WebFlux + 코루틴과 거의 비슷한 성능을 보여준다.


5. 코루틴과 버추얼 스레드와 통합

구조적 동시성: 동시 작업의 결과에 대한 제어



코루틴이 버추얼 스레드 위에서 동작된다.
mysql Synschronized와 같이 동시에 사용하기엔 성능 이슈가 있다.




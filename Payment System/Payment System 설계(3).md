# 시스템 설계: Deep Dive

## Database 선택

일반적인 결제 시스템에서는 성능이 그렇게 중요하지 않다. 왜냐? 결제 요청 트래픽은 많지 않기 때문이다. 회사의 비즈니스가 성장하여 확장성을 제공할 수 있어야 한다.

결제 시스템에서는 일관된 상태의 데이터 저장능력과 높은 데이터베이스 숙련도가 요구된다.

데이터베이스 또한 결국 소프트웨어 스킬을 사용하기에 버그가 발생할 수 있는데, 데이터베이스 내부의 버그로 인해 데이터 상태가 손상되면 이는 치명적인 문제를 초래한다.

이러한 관점에서 보면, 관계형 데이터베이스가 적합하다고 볼 수 있다.

## Microservice VS Monolithic

결제 시스템에 필요한 다양한 서비스들을 하나로 합쳐서 모노리식으로 운영하는 것이 좋을까? 아니면 마이크로서비스로 나눠 운영하는 것이 좋을까??

각각의 장단점이 분명하다.

- 마이크로서비스의 장단점:
    - 서비스를 독립적으로 배포하고 운영할 수 있다.
    - 한 서비스의 장애를 격리시키기 쉽다.
    - 모니터링과 디버깅이 어려울 수 있다.
- 모놀리식의 장단점:
    - 운영이 간단하다
    - 디버깅과 테스팅이 상대적으로 쉽다.
    - 마이크로서비스와 달리 네트워크를 통한 통신을 사용하지 않아도 될 수 있다.
    - SPOF (Single Point Of Failure)가 존재할 가능성이 많다.

결제 시스템의 가장 중요한 요구사항인 신뢰성(Reliability)을 고려하면, 마이크로서비스 형태가 적합하다.

## Communication Style

마이크로서비스를 선택했다면 각 서비스 간의 통신 방식을 결정해야 한다.

통신 방식은 크게 두 가지로 나뉜다.

- **동기 통신 (Synchronous Communication):** HTTP와 같은 프로토콜을 사용하여 통신하는 방식
- **비동기 통신 (Asynchronous Communication):** 메시지 큐를 사용하여 통신하는 방식

사용자의 결제 요청을 처리할 때는 즉시 응답을 제공해야 하므로 동기식 커뮤니케이션이 적합하다. 그리고 동기식 커뮤니케이션에서도 내/외부와의 통신이 많은 Payment Service는 논블로킹 통신이 사용되는 Spring Webflux와 같은 네트워크 통신 라이브러리가 적합하다.

PSP를 통해 결제 승인 후 사용자에게 응답을 보낸 이후에는 동기식 처리가 필요없다. 따라서, 이후 프로세스에서는 결제 승인 이벤트 발행을 통한 비동기식 통신을 고려할 수 있다. 동기식 통신은 결합도가 높고, 확장성과 성능 측면에서는 비동기식보다 비효율적이다. 이러한 이유로 가능하다면 메시지를 이용한 비동기식 통신이 적합하다고 판단된다.

추가로 만약 사용자에게 결제 요청 처리에 대한 즉각적인 응답을 제공할 필요가 없다면, 처음부터 비동기 기반의 커뮤니케이션을 고려해볼 수 있다.

이 방식은 결제 요청을 일단 모두 수락해서 메시지 큐에 보내므로, 급증하는 결제 트래픽에서도 쉽게 대응할 수 있다. 하지만, 재고 소진과 같은 문제로 인해 결제가 진행될 수 없고 트랜잭션에 대한 관리도 용이하게 이뤄지며 보상에 대한 프로세스 설계도 요구된다.

## Message Delivery Guarantees

비동기식 통신에 메시지 큐를 이용하기로 결정했다면, **메시지 전달 보장 수준**에 대해 고려해야한다.

주로 다음과 같은 세 가지 수준이 있다.

- At most once (최대 한 번)
- At least once (최소 한 번)
- Exactly one (정확히 한 번)

결제 시스템에서는 결제 승인 메시지를 'At least once (최소 한 번)' 전달하는 것이 보장되어야 한다. 만약 메시지가 전달되지 않고 유실된다면 결제 데이터의 일관성이 훼손될 수 있기 때문이다. 'At least once (최소 한 번)' 원칙에 따라 메시지가 여러 번 전송되더라도 큰 문제는 아니다. 메시지가 여러 번 처리되지 않게 멱등성을 활용하여 처리하면 된다.

## Idempotency (멱등성)

멱등성 처리는 데이터 상태를 변경할 수 있는 요청이 여러 번 들어와도 최대 한 번만 처리하도록 설계하는 방법을 의미한다.

![image](https://github.com/user-attachments/assets/2e96b9e9-dbdb-4555-a79d-4a315fe3662f)


예를 들어, 결제 승인을 위해 PSP 에 요청을 보낼 때, 타임아웃으로 인해 재시도가 필요할 수 있다. 만약 재시도가 발생하고 이전 요청이 결제 승인을 받았지만 네트워크 혼잡으로 인해 응답이 오지 않았다면, 재시도 요청으로 인해 두 번 결제가 발생할 수 있다. 이러한 상황을 방지하기 위해, 요청이 오직 한 번만 처리되도록 멱등성을 활용해야한다.

API 처리에서 멱등성을 이용하는 방법은 API 제공 업체마다 다르지만, 일반적으로 Request Header에 <idempotency-key: key_value> 를 추가하여 보내면 된다. 이때 중요한 점은 **멱등성 키**의 값으로 각 요청을 식별할 수 있는 고유한 값을 주어야 한다는 것이다. 이 값으로 중복 처리를 방지한다.

API를 사용할 때 뿐만 아니라 데이터베이스에 데이터를 삽입할 때도 이러한 멱등성 처리를 활용할 수 있다. JDBC를 통해 데이터를 삽입하는 경우, 응답이 없어 재시도하게 되면 두 번 데이터가 삽입되는 경우가 발생할 수 있다. 이를 방지하기 위해 멱등성 키를 유니크한 칼럼으로 설정하면, 데이터는 최대 한 번만 삽입되며, 그 이후의 시도는 무결성 제약 조건으로 인해 실패하게 된다. 이와 같은 방법으로 멱등성을 보장할 수 있다.

## Consistency (일관성)

### 1. 결제 승인 이벤트 메시지 전달 보장

결제 승인 후에는 결제 승인 결과를 데이터베이스에 저장하며, 메시지 큐를 통해 결제 승인 이벤트를 전달해야 한다. 즉, 데이터베이스 저장과 메시지 전달은 둘 중 하나만 성공하는 것이 아니라, 둘 다 성공하거나 둘 다 실패해야 한다.

이를 위한 가장 간단한 접근 방법은 2PC (Two-Phase Commit)를 이용한 Atomic 연산을 고려하는 것이지만, 카프카와 같은 메시지 큐는 이를 지원하지 않는다. 물론 RabbitMQ 와 같은 메시지 큐 서비스는 2PC 를 지원하긴 하나, 이 이유 하나 때문에 메시지 큐를 선택하는 건 합리적이지 않고, 2PC 방법은 상태 유지가 필요하고, 네트워크에 큰 영향을 받는다는 단점이 있다.

다음으로 고려해볼 방법은 `@Transactional`을 이용해 트랜잭션 영역 내에서 결제 승인 정보를 데이터베이스에 저장하고 메시지 큐로 메시지를 전송하는 것이다. 이 방법은 메시지 큐로의 메시지 전송이 실패하면 트랜잭션도 롤백할 수 있다는 장점이 있다. 그러나 이 방법에는 **메시지는 전송되었지만 트랜잭션이 롤백되는**는 문제가 발생할 수 있으므로 적합하지 않다.

이 문제를 해결하기 위한 방법 중 하나는 `Transactional OutBox Pattern`을 사용하는 것이다. 이 패턴은 결제 승인 정보를 데이터베이스에 저장할 때, 동일한 트랜잭션에서 메시지 큐에 전달할 이벤트들도 함께 데이터베이스에 저장하는 방법이다. 이렇게 저장된 이후에 데이터베이스에 저장된 이벤트 메시지들을 가져와 메시지 큐로 전달하는 방식을 사용하면, 이벤트 전달과 데이터베이스 반영 모두 성공할 수 있다.

### 2. 이벤트 메시지 처리 & 전달 보장

이벤트 메시지 처리와 전달은 Wallet Service 와 Ledger Service 에서 일어난다. Wallet Service 와 Ledger Service 는 결제 승인 이벤트 메시지를 받아 처리하며, 처리가 완료되면 완료 이벤트 메시지를 발행하므로.
여기서 중요한 점은 카프카와 같은 메시지 큐 서비스에서 "메시지 발행" 이후에 “메시지를 처리했다는 커밋" 작업이 이루어져야 한다는 것이다. 만약 메시지 커밋을 먼저 하고 메시지 발행에 실패하면 Payment Service는 이벤트를 수신하지 못하니 결제는 완료 상태로 되지 못한다. 즉, 일관성이 깨지는 문제가 발생할 수 있다.

카프카에서는 내부적으로 **트랜잭션** 기능을 이용하여 “메시지 발행"과 “메시지 커밋"을 원자적으로 처리할 수 있다. 이 기능을 사용하면 메시지 처리를 하면서도 메시지의 전달을 보장할 수 있다. 

### 3. Optimistic Locking 이용

Wallet Service 가 단일 인스턴스가 아닌 다수의 인스턴스로 운영된다면 판매자가 받아야 할 정산 금액이 동시에 업데이트되는 경우가 생길 수 있다. 즉 동시에 진행되는 트랜잭션으로 인해 갱신 내용이 덮어씌워지는 동시성 이슈인 Lost Update가 발생할 가능성이 있다.

동시성을 제어하는 다양한 방법이 있지만, 충돌이 자주 발생하지 않을 것이므로, Lock을 이용하는 방식보다는 Optimistic Locking을 이용하는 방식이 적합해보인다.

### 4. Database Trigger 이용

Ledger Service에서 장부에 Double Entry 방식으로 기록할 때, 데이터베이스 트리거를 사용해 정확한 데이터들을 입력했는지 검증할 수 있다. 이를 통해 일관성을 깨는 데이터 입력을 방지할 수 있고, 또 트리거를 사용해 장부의 데이터를 변경 불가능하게 만드는 것도 가능하다.

Ledger Service 의 장부 기입과 Wallet Service 의 정산 처리가 모두 완료되면 이벤트를 발행하며, Payment Service 는 이 이벤트를 수신하여 결제를 완료한다. 그러나 동시에 이 두 이벤트를 처리하는 경우, Payment Service 는 최신 상태의 결제 데이터를 읽지 못하고 결제를 완료 상태로 업데이트하지 못하는 문제가 발생할 수 있다. 이런 동시성 문제 또한 트리거를 이용하여 해결할 수 있습니다.
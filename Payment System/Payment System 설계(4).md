## Reliability 와 Fault tolerance를 주는 법

### 1. Handling Failed Payment Using Retry

구매자가 결제 정보를 입력하고 인증한 후, Payment Service에서 PSP로 결제 승인에 성공해야만 거래가 완료될 수 있다. 그러나 서버 측에서 결제 승인 과정 중에 Payment Service가 중단된다면, 결제는 완료되지 않는 상태로 남게 될 것이다.

그러므로 이런 문제에 대비하는 것이 중요하며, 우리는 ‘재시도’ 기반으로 이 문제를 해결할 것이다.

먼저, 결제 상태는 NOT_STARTED, EXECUTING, SUCCESS, FAILURE, UNKNOWN으로 나뉜다.

<img width="505" alt="image" src="https://github.com/user-attachments/assets/ab61baed-97d9-4633-af0e-76311c45e402">

결제 승인이 시작되면, 가장 먼저 결제 상태를 NOT_STARTED에서 EXECUTING으로 변경하는 것부터 시작한다. EXECUTING 상태가 되면 이제 결제 승인은 성공적으로 완료되거나 실패할 수 있다. 만약 일정 시간이 지나도 결제 상태가 성공 또는 실패로 명확하게 변경되지 않고, EXECUTING 상태로 남아있거나 처리 중 알 수 없는 문제가 발생하여 UNKNOWN 상태로 변경된 경우, 주기적으로 재시도하여 문제를 해결하는 방법이다.

기본적으로 재시도를 통해 문제를 해결하기 때문에, 이전에 설명한 멱등성(Idempotency) 처리를 할 수 있도록 만드는 것이 중요합니다.

### 2. Retry Queue와 Dead Letter Queue

Wallet Service와 Ledger 서비스는 결제 승인 이벤트 메시지를 수신해서 처리하는 방식으로 설계되었다.

중요한 건, 메시지 처리가 실패할 때의 대응 전략을 설계해야 한다.

실패한 메시지를 무시하도록 전략을 수립하면 메시지 처리에 손실이 발생하여 일관성이 훼손된다. 반면에, 실패한 메시지를 성공할 때까지 재시도하는 전략을 수립하면 메시지 처리가 계속 지연되어 블로킹되는 문제가 발생한다.

메시지 손실을 방지하고 메시지 처리가 블로킹되지 않도록 하기 위해 Retry Queue와 Dead Letter Queue를 사용할 수 있다. 메시지 처리에 실패하면 해당 메시지를 Retry Queue에 기록하고, 메시지를 다시 가져와서 재시도한다. 만약 재시도가 threshold 값만큼 실패하면, 이를 Dead Letter Queue에 기록하고 이후에 수동으로 대응하는 전략을 사용해서 문제를 해결할 수 있다.

![image](https://github.com/user-attachments/assets/97d7ccc2-3f85-4460-a394-ecbfff017f8d)

### 3. Reconciliation 프로세스 추가

PSP 업체에서는 지정된 날짜에 모든 거래 내역이 포함된 정산 파일(Settlement)을 받을 수 있다. 매일 자정마다 이 파일을 이용하여 누락된 결제를 추가하고, 잘못 처리한 결제된 내역 을 정정하면, 결제는 모두 정확하게 처리될 수 있다.

즉, Reconciliation(조정 및 화해) 프로세스를 추가하여 그 날의 모든 결제 내역을 검토함으 로써 누락된 결제를 추가하고, 잘못 처리된 결제가 있는지 조사하고 이를 정정해 일관성을 유지할 수 있다.

Reconciliation 프로세스를 최종 방어 역할로 사용하면 보다 견고한 결제 애플리케이션을 만들 수 있다.

### 4. (Optional) Message Order 보장

결제 프로세스에는 성공만 있는 것이 아니라 취소도 포함된다. 만약 결제 완료 메시지를 수신하기 전에 결제 취소 메시지가 먼저 도착하고 처리를 요구한다면, 이는 정상적인 절차가 아니다. 따라서 결제의 경우, 취소 메시지가 완료 메시지보다 항상 늦게 처리되도록 보장해야한다.

메시지 큐로 카프카를 사용하면, 카프카 내의 토픽 파티션을 통해 메시지 처리 순서를 보장 할 수 있다. 같은 파티션 내에서는 메시지가 순서대로 저장되어 있고, 이는 컨슈머에 의해 순 서대로 처리되기 때문이다.

따라서, 결제의 성공/취소 메시지는 동일한 파티션으로 전송되어야 한다. 카프카에서는 키를 사용하여 지정된 파티션으로 메시지를 보낼 수 있다. 예를 들면, 구매자의 1d 값을 사용하여 파티션을 지정하면 메시지의 순서가 보장될 것이다.

그러나 이 방법은 Single Producer 일 때만 가능하다. 만약 Multiple Producer를 이용하 게 된다면 경쟁적으로 메시지를 보내게 될테니 이 방법은 적합하지 않다. 이때는 Global Message Sequence 를 제공하거나, 여러 Producer 가 각자 하나씩 토픽 파티션을 맡도 록 파티셔닝 해야 한다.

그리고 만약 메시지 처리에 순서를 보장하는 것이 아닌 인과성 정도만 필요하다면, 보다 늦게 처리해야 하는 메시지를 큐 끝에 다시 넣는 Requeue를 이용해볼 수도 있다.